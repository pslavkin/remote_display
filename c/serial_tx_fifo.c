#include <serial_tx_fifo.h>
#include <serial_tx.h>
#include <state_machine.h>

//--------------------------------------------------------------------------
#define MAX_MESSAGES 250                //tengo que bancar muchos mensajes porqu el acelerador de rotary me llena la cola sino...

static struct Serial_Tx_Message Buffer[MAX_MESSAGES+1];     //array usado de buffer para almacenar los datos...
static unsigned char Point2Write;               //puntero para escritura...
static unsigned char Point2Read;             //puntero para lectura...
 
static unsigned char Next_Pointer(unsigned char Actual)  {return Actual==MAX_MESSAGES?0x00:(Actual+1);}
//-----------------------------------------------------------------------------
void Init_Serial_Tx_Fifo(void)   {Point2Read = Point2Write = 0x00;}  //inicializa la cola circular de eventos...
//-----------------------------------------------------------------------------
void Add_Serial_Tx_Message(char* Start,unsigned int Size,unsigned char Type,State** Sm)   //escribe un nuevo dato a la cola...
{
 if (Next_Pointer(Point2Write)!=Point2Read)           //si el siguiente casillero no esta apuntado por Point2Read...
   {
    Buffer[Point2Write].Start=Start;      //almacena el dato...
    Buffer[Point2Write].Size =Size;    //almacena el dato...
    Buffer[Point2Write].Type =Type;    //almacena el dato...
    Buffer[Point2Write].Sm =Sm;        //almacena el dato...
    Point2Write = Next_Pointer(Point2Write); //apunta al siguiente...
   }
}
void Atomic_Add_Serial_Tx_Message(char* Start,unsigned int Size,unsigned char Type,State** Sm)     {Atomic(Add_Serial_Tx_Message(Start,Size,Type,Sm));}
//-----------------------------------------------------------------------------
struct Serial_Tx_Message Atomic_Read_Serial_Tx_Message ( void ) // lee el proximo dato de la cola...
{
 struct Serial_Tx_Message Ans = {0,0,0,0};
 Disable_Irq();
 if (Point2Read != Point2Write)        //si los apuntadores son diferentes,es porque hay algo para leer...  
   {
    Ans=Buffer[Point2Read];         //auxiliar para guardar la respuesta, que por defoult se graba la data de la posicion actual...
    Point2Read = Next_Pointer(Point2Read);   //se incrementa el puntero...
   }
 Enable_Irq();
 return Ans;               //notar que si no hay nada para leer, devuelve simempre el ultimo dato escrito...
}
//-----------------------------------------------------------------------------
unsigned char Serial_Tx_Fifo_Messages(void)
{
 return (Point2Write>=Point2Read)?(Point2Write-Point2Read):(Point2Read-Point2Write);   //devuelve el numero de mensajes pendientes...
}
unsigned char Serial_Tx_Fifo_Empty(void)
{
 return Point2Write==Point2Read;    //si son iguales los apuntadores, no hay nada para leer...
}
unsigned char Read_Message_Type(void)
{
 return Serial_Tx_Fifo_Empty()?End_Of_Messages_Event:Buffer[Point2Read].Type; //envia el tipo de transmision solicitada o fin de mensages...
}
//-----------------------------------------------------------------------------
